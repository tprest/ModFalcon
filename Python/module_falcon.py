"""Implementation of module-Falcon."""

from numpy import set_printoptions
from math import sqrt, ceil, floor
from fft import fft, ifft, sub, mul_fft
from ntt import add_zq, mul_zq
from ffsampling import ffldl_fft, ffsampling_fft
from ffsampling import print_tree, normalize_tree
from ntrugen import module_ntru_gen, bitsize
from random import randint
from linalg import vecmatmul_fft, gram
from encoding import compress, decompress

# If Python has version >= 3.6, then the built-in hashlib has shake_256.
# Otherwise, sha3 has to be loaded to monkey-patch hashlib.
# See https://pypi.python.org/pypi/pysha3.
import sys
import hashlib
if sys.version_info < (3, 6):
    import sha3


set_printoptions(linewidth=200, precision=5, suppress=True)


class PublicKey:
    """
    A module-Falcon public key

    Attributes;
    d               The degree of the underlying ring R = Z[x] / (x ** d + 1)
    m               We work over a R-module of rank (m + 1)
    q               The integer modulus
    hash_to_point   The underlying hash function
    signature_bound The acceptable bound for the norm of the signature
    """
    def __init__(self, sk):
        """Compute the public key corresponding to a private key."""
        self.d = sk.d
        self.m = sk.m
        self.q = sk.q
        self.A = sk.A
        self.hash_to_point = sk.hash_to_point
        self.signature_bound = sk.signature_bound
        self.verify = sk.verify
        self.rate = sk.rate


class SecretKey:
    """
    A module-Falcon private key

    Attributes;
    d               The degree of the underlying ring R = Z[x] / (x ** d + 1)
    m               We work over a R-module of rank (m + 1)
    q               The integer modulus
    hash_to_point   The underlying hash function
    sigma           The standard deviation of the signature
    signature_bound The acceptable bound for the norm of the signature
    B               The private key matrix (Coefficient)
    B_fft           The private key matrix (FFT)
    invB_fft        The inverse of B_fft (FFT)
    G_fft           The Gram matrix of B_fft (FFT)
    T_fft           The LDL decomposition tree of G_fft (FFT)
    A               The public key matrix (Coefficient)
    """
    def __init__(self, d, m, q):
        """
        Initialize a secret key.
        """
        # Public parameters
        self.d = d
        self.m = m
        self.q = q
        self.hash_function = hashlib.shake_256
        slack = 1.1
        smooth = 1.28
        while(1):
            try:
                # Key generation
                self.A, self.B, invB, self.sq_gs_norm = module_ntru_gen(d, q, m)
                G = gram(self.B)
                self.B_fft = [[fft(elt) for elt in row] for row in self.B]
                self.invB_fft = [[fft(elt) for elt in row] for row in invB]
                G_fft = [[fft(elt) for elt in row] for row in G]
                self.T_fft = ffldl_fft(G_fft)
                self.sigma = smooth * sqrt(self.sq_gs_norm)
                self.signature_bound = slack * (self.m + 1) * self.d * (self.sigma ** 2)
                normalize_tree(self.T_fft, self.sigma)
                self.rate = bitsize(int(round(self.sigma))) - 2
                # print("self.rate =", self.rate)
                return
            except ValueError:
                continue


    def __repr__(self, verbose=True):
        """
        Print the private key in readable form.
        """
        rep = "Private key for d = {d}, m = {m}, q = {q}:\n\n".format(d=self.d, m=self.m, q=self.q)
        rep += "A = {A}\n".format(A=self.A)
        rep += "B = {B}\n".format(B=self.B)
        if verbose:
            rep += "\nFFT tree\n"
            rep += print_tree(self.T_fft, pref="")
        return rep

    def get_coord_in_fft(self, point):
        """
        Compute t such that t * B = point.
        Useful for the signing procedure.

        Input:
        self        The private key
        point       A row vector in the span generated by B

        Output:
        t           A vector such that t * B = point

        Format:
        Input       Coefficient
        Output      FFT
        """
        zero = [0] * self.d
        t = [fft(point)] + [zero[:] for _ in range(self.m)]
        t = [mul_fft(t[0], self.invB_fft[i][0]) for i in range(self.m + 1)]
        return t

    def hash_to_point(self, message, salt):
        """
        Hash a message to a point in Z_q[x] / (x ** d + 1).
        Inspired by the Parse function from NewHope.
        Useful for the signing and verification procedures.

        Input:
        self        The private key
        message     The message to hash
        salt        The hashing salt

        Output:
        hashed      the hash H(m||salt) onto Z_q[x] / (x ** d + 1)

        Format:     Coefficient
        """
        d, q = self.d, self.q
        if q > 2 ** 16:
            raise ValueError("The modulus is too large")

        k = (2 ** 16) / q
        # We take twice the number of bits that would be needed if there was no rejection
        emessage = message.encode('utf-8')
        esalt = salt.encode('utf-8')
        # Compute the hash digest
        hash_instance = self.hash_function()
        hash_instance.update(esalt)
        hash_instance.update(emessage)
        digest = hash_instance.hexdigest(8 * d)
        # Transform the hash digest into an element of Z_q[x] / (x ** d + 1)
        hashed = [0 for i in range(d)]
        i = 0
        j = 0
        while i < d:
            # Takes 2 bytes, transform them in a 16 bits integer
            elt = int(digest[4 * j: 4 * (j + 1)], 16)
            # Implicit rejection sampling
            if elt < k * q:
                hashed[i] = elt % q
                i += 1
            j += 1
        return hashed

    def sample_preimage_fft(self, point):
        """
        Sample preimage.

        Input:
        self        The private key
        point       An element of Z_q[x] / (x ** d + 1)

        Output:
        s           A short element such that s * B = point

        Format:     Coefficient
        """
        d = self.d
        m = self.m
        # Compute large preimage
        c = [point] + [[0] * d for _ in range(m)]
        # Move to FFT domain
        c_fft = [fft(elt) for elt in c]
        # Compute coefficients in span(B)
        t_fft = vecmatmul_fft(c_fft, self.invB_fft)
        # Fast Fourier sampling
        z_fft = ffsampling_fft(t_fft, self.T_fft)
        # Compute short preimage s = (c - v) = (t - z) * B
        v_fft = vecmatmul_fft(z_fft, self.B_fft)
        v = [[int(round(coef)) for coef in ifft(elt)] for elt in v_fft]
        s = [sub(c[i], v[i]) for i in range(m + 1)]
        return s

    def sign(self, message, salt=None, verbose=False):
        """
        Sign a message. Needs hash randomization to be secure.

        Input:
        self        The private key
        message     The message to sign
        salt        The hashing salt (optional)
        verbose     If this flag is set, the algorithm notifies each time it restarts

        Output:
        r, s        A signature of the message:
                    - s * A = H(r||message)
                    - s is short
        """
        # If no salt is provided, one is generated randomly
        if salt is None:
            salt = randint(0, (1 << 320) - 1)
        # The message is hashed into a point of Z_q[x] / (x ** d + 1)
        r = ""
        for i in range(320 // 8):
            r += chr((salt >> (8 * i)) & 0xff)
        hashed = self.hash_to_point(message, r)
        # A short pre-image of this point is determined
        while(1):
            s = self.sample_preimage_fft(hashed)
            # The norm of the signature is checked
            norm_sign = sum(sum(elt**2 for elt in part) for part in s)
            if norm_sign < self.signature_bound:
                return r, compress(s, rate=self.rate)
            elif verbose is True:
                print("redo")

    def verify(self, message, signature):
        """
        Verify a signature.

        Input:
        self        The private key
        message     The message to sign
        signature   The signature (r, s)

        Output:
        True        If (s * A == H(r||message)) and (s is short)
        False       Otherwise
        """
        A = self.A
        q = self.q
        d = self.d
        m = self.m
        r, t = signature
        s = decompress(t, self.d, self.rate)
        # The message is hashed to a point of Z_q[x] / (x ** d + 1)
        hashed = self.hash_to_point(message, r)
        # One compute result = s * A
        result = [0] * d
        for i in range(m + 1):
            result = add_zq(result, mul_zq(s[i], A[i], q), q)
        # Check that the hashed point == result
        if any(result[i] != hashed[i] for i in range(d)):
            print("The signature does not correspond to the hash!")
            return False
        # Check that the norm is small
        norm_sign = sum(sum(elt**2 for elt in part) for part in s)
        if norm_sign > self.signature_bound:
            print("The squared norm of the signature is too big:", norm_sign)
            return False
        # If the two checks passed, accept
        return True
